03/10/2020
Installé au coworking de Lacanau, avec Ben et Séb

Thème Jam : "Stuck in a loop" (https://ldjam.com/events/ludum-dare/47)

Travail sur document de design

J'ai un premier document, avec des idées précises pour le design des niveaux
=> je vais commencer par ça pour fixer les idées

Utilisation de la mécanique de "MeshLib" + "GridMap" Godot
https://www.youtube.com/watch?v=UGltqKZFxrs
https://www.youtube.com/watch?v=jD04Tua191Q
https://www.youtube.com/watch?v=OYn49ghh9k0

Modélisation des tuiles :
Carrés de taille fixée
- partir de cubes applatis pour ne pas avoir de soucis de rendu par manque d'épaisseur
- Conserver le centre au centre de la tuile (pour placement et rotations plus faciles dans Godot)
- ? Avoir Z=0 (Y=0 pour Godot) pour le centre pour faciliter calculs dans le code ensuite ?
- Mutualiser les matériaux pour pouvoir changer d'avis sur le style
- Choisir une palette !

Pour le workflow gridmap, cf. gridmap.txt

Palette : j'essaie colormind.io sur une image trouvée via "desert far west trains cactus"
=> que de petites palettes (5 couleurs)

Séb me recommande https://lospec.com/palette-list
Je prend la palette Pico-8 : https://lospec.com/palette-list/pico-8

Taille modèles : dans Godot, une unité = 1 mètre
Je vais conserver la taille du cube par défaut dans Blender => tuiles de 2x2 mètres

Pour le workflow modé / palette, cf mesh_coloring.txt

Beaucoup de mal à construire une meshlib correcte, je ne trouve pas le bon workflow depuis glb

Je renonce à l'approche "Meshlib + gridmap" : pas trouvé comment efficacement travailler

J'installerais bien https://gestaltor.io/ pour mieux comprendre le contenu de mes modèles,
mais pas de version gratuite

Après discussion avec Séb et Ben : le level design / éditeur de niveau est une pierre
d'achoppement très classique, et les outils intégrés "GUI" sont souvent décevants
=> coder moi-même une mécanique d'instanciation du niveau à partir d'un fichier
   de description (texte, bitmap...) est un passage normal, et qui me donnera plus
   de liberté par rapport aux outils

Je pars donc sur l'approche suivante :
- un tileset.blend unique contenant toutes mes tuiles (avec un mesh ou un empty parent en racine pour chacun)
- je les positionne côte à côte, sans les centrer mais avec une translation entière (2) à chaque fois
- je positionne dans cette même scène une caméra (perspective) et une lumière pour avoir une idée du rendu

Pour courber les rails à partir de la tile "straight", j'utilise le modifier "Simple Deform"
Difficile à intuiter, bon exemple : https://www.youtube.com/watch?v=iq2_goboheo

Pas simple, même avec un exemple... Il faudrait extruder le long d'une courbe peut-être ?
J'ai fini pas extruder à la main et par bouger les traverses manuellement, pas très heureux...

Pour une vue "isométrique", réglages caméra :
- Projection : Orthogonal
- Size : augmenter (1 par défaut, trop petit ; joue le rôle de la "distance")
- angles : x=45, up=y=35.264 (https://en.wikipedia.org/wiki/Isometric_projection#Rotation_angles)

Bof. Pas simple à placer
Des conseils ici (Unity) :
https://answers.unity.com/questions/12027/how-to-do-a-camera-that-is-top-downisometric.html
"Create an empty GameObject called 'CameraTarget' at (0,0,0). Create a camera at (0,0,-10).
 Parent the Camera to the CameraTarget. Set the rotation of the Camera Target to (30,45,0)
 then check 'Orthographic' under the Camera settings. Adjust the 'Orthographic Size'
 camera setting to change the amount of zoom. Move the CameraTarget around the world to
 change the focal point on the map."
 
Transposé à Godot : caméra en (0,0,10), taille > 1, rotations ?

Des schémas ici :
https://gamedev.stackexchange.com/questions/74782/rendering-models-in-isometric-view
https://en.wikipedia.org/wiki/Isometric_video_game_graphics
(!) https://web.archive.org/web/20170426055522/https://flarerpg.org/tutorials/isometric_tiles/

Je vais faire des tests avec une scène "vide"
Je n'arrive pas à transposer les angles de caméra...

J'ai pu faire une scène convenable dans blender en suivant :
http://clintbellanger.net/articles/isometric_tiles/

Je vais essayer de faire l'équivalent dans Godot, en important cette scène directement :
- export de la scène Blender en glTF (en cochant Include > Cameras et +Y Up)
- import godot

La correspondance semble décente... Distance / taille pas identique, mais échelle si
Blender : caméra en (10, -10, 9), rotations (60, 0, 45), orthographic scale : 10
Godot :
- caméra a un parent en (10, 9, 10) ayant une rotation de (60, 45, 0)
- la caméra elle-même a une rotation de (-90, 0, 0), size : 10

Rendu Godot identique avec caméra par défaut et parent en (10, 9, 10) ayant une rotation de (-30, 45, 0)

Ce qu'il me manquait lorsque j'ai transposé les angles à la main :
- la caméra doit être en hauteur pour "surplomber" la scène
- une rotation Y pour être "en diagonale" (ce point était OK)
- une rotation *negative* sur l'axe des X pour se "pencher" vers l'origine (j'étais en angle nul ou positif)

Ensuite on peut "centrer" verticalement avec la position Y de la caméra, et "zoomer" avec la size

J'ai pu retoucher mes scènes de test et obtenir des rendus proches de Blender

J'ai commité un exemple de script recréant une "PackedScene" à partir d'un mesh faisant
partie d'une scène glb importée plus vaste, ce qui permet ensuite de réinstancier ce mesh
plusieurs fois programmatiquement

Deux possibilités à ce stade :
- écrire un script "postimport" ventilant un glb importé en ses sous-objets "racines",
  puis les sauvant sous forme de tscn
  => ensuite utilisables via mécanique de design de niveau habituelle (instanciation dans une scène parente)
- implémenter l'approche "fichier de description de niveau"

Pas tout à fait orthogonal, puisque la seconde approche peut bénéficier d'une ventilation vers tscn
(permet de découpler l'origine des assets de leur utilisation)

Cependant les règles d'extraction des sous-noeuds sont vraiment ad-hoc...

Je vais faire une mécanique de chargement de bitmap où les metadata (mapping couleur -> mesh,
identification de ce dernier) sont programmatiques (structure de donnée Godot) et interagissent
avec du code de "chargement/réinstanciation" (donc maps couleur => factory,
ce qui permet d'inclure des rotations ?)

Après quelques tests, il n'est pas si simple de faire du layout de tuiles "à la main" avec du spanning
dans l'éditeur 3D : soucis de coordonnée y, de parenting... cf https://godotforums.org/discussion/comment/42407
Donc un éditeur "externe" a du sens

J'ai pu faire un "niveau" sous forme d'un bitmap avec des couleurs simples dans "Pixelorama"
https://orama-interactive.itch.io/pixelorama

Sauve sous forme de PNG ; dans Godot, modification des options d'importation :
"Import As" > "Image" (relance l'éditeur !)
(Il y a aussi bitmap ?)
On peut ensuite charger l'image dans un : https://docs.godotengine.org/fr/stable/classes/class_image.html
=> accès aux pixels, dimension...
            var image = Image();
            image.load(path);

			
04/10/2020
Réflexions nocturnes :
- l'approche ci-dessus "in memory" ne permet pas d'appliquer l'étape "Create Trimesh Static Body"
- on peut vouloir le faire à la main pour discerner le sol et obstacle des "décorations" (props)
- pouvoir mettre des "collision shapes" dès Blender serait pratique pour ce cas

On va se passer de physique pour aujourd'hui...

Séb m'a présenté son outil Led : très intéressant pour du design rapide de niveau,
y compris en vue de dessus / isométrique
Beaucoup de règles et d'équilibrages peuvent s'y représenter
Des règles procédurales pour placer des props pseudo-aléatoirement

J'ai pu charger le bitmap, généraliser le chargement des assets et les placer via un switch
Le placement de caméra interactivement dans godot pendant que le jeu tourne est pratique...

Je fais un peu de tuning de l'éclairage : repasser en GL ES 3 améliore significativement
le rendu (meilleures ombres, moins d'artefacts sur tuiles contigues)
Doc sur tuning paramètres ombres :
https://docs.godotengine.org/en/latest/tutorials/3d/lights_and_shadows.html#shadow-mapping

Je crée une coure de Bézier quadratique pour avoir quelque chose à "suivre"

Approximer quart de cercles : pas simple !
http://www.whizkidtech.redprince.net/bezier/circle/
https://spencermortensen.com/articles/bezier-circle/

Je n'aurai pas les coins "en aveugle" avec des Bézier : trop compliqué à mettre au point
